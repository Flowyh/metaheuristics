using TSPLIB
using Random
using Plots
import UnicodePlots
using Dates

"""
    structToDict(s) -> Dict

Converts struct object to Dict.

Ref: https://stackoverflow.com/a/70317636.

## Params:
- `s::Struct`: struct obj to convert to dict.

## Returns:
- `Dict`: struct converted to dict.

"""
function structToDict(s)
  return Dict(key => getfield(s, key) for key in propertynames(s))
end

"""
    nodeWeightSum(path, weights) -> Float64

Returns path's weight.

## Params:
- `path::Vector{T<:Integer}`: visited nodes in a given path.
- `weights::AbstractMatrix{Float64}`: matrix of weights between nodes.

## Returns:
- `Float64`: Sum of weights between nodes in given path.

"""
function nodeWeightSum(path::Vector{T}, weights::AbstractMatrix{Float64}) where T<:Integer
  @assert isperm(path) "Invalid path provided"
  result = length(path) != size(weights, 1) ? zero(Float64) : weights[path[end], path[1]]
  for i = 1:length(path)-1
    result += weights[path[i], path[i + 1]]
  end
  return result
end

"""
    getPathCoordsVector(path, coords) -> (Array{Float64}, Array{Float64})

Create a tuple of X and Y coords arrays in given path order.

## Params:
- `path::Vector{T<:Integer}`: visited nodes in a given path.
- `coords::AbstractMatrix{Float64}`: nodes' coordinates.

## Returns:
- Two element tuple of X/Y coords arrays. 

"""
function getPathCoordsVector(path::Vector{T}, coords::AbstractMatrix{Float64}) where T<:Integer
  x = Vector{Integer}();
  y = Vector{Integer}();
  for node in path
    node_coords = coords[node, :]
    append!(x, node_coords[1])
    append!(y, node_coords[2])
  end
  append!(x, coords[path[1], 1])
  append!(y, coords[path[1], 2])
  return (x, y)
end

"""
    openTSPFile()

Asks for `TSP` data direcory path and filename.

Opens the file and returns a struct type generated by TSPLIB.

## Returns:
- `TSP`: struct read from file from path.

"""
function openTSPFile()
  println("Hello! Please provide full path to your data folder: ")
  path = chomp(readline())
  for (root, dirs, files) in walkdir(path)
    global options = files
  end
  filter!(s->occursin(r".tsp", s), options)
  for el in options
    for i in 1:4 print(el, "   ") end
    println()
  end
  println()
  println("Choose a file by writing a full file name:  ")
  response = chomp(readline())
  return readTSP(path * "/" * response)
end

"""
    krandom(tsp_data) -> Array{Integer}

Returns a random permutation of given length.

## Params:
- `tsp_data::Dict`: `TSP` dataset.

## Returns:
- Permutation of `TSP` dataset nodes.

"""
function krandom(tsp_data::Dict, args...)
  return shuffle(collect(1:tsp_data[:dimension]))
end

function nearestNeighbour(tsp_data::Dict, args...)
  if (length(args) < 1) return end
  len = tsp_data[:dimension]
  path = Vector{Int}()
  current_point = args[1]
  push!(path, current_point)

  for i in 1:(len-1)
    weights = tsp_data[:weights][path[i], :]
    current_weight = typemax(Float64)
    index = 1
    for weight in weights
      if (!(index in path) && current_weight > weight && weight != 0)
        current_weight = weight
        current_point = index
      end
      index += 1
    end
    index = 1
    push!(path, current_point)
  end
  return path
end

function repetitiveNearestNeighbour(tsp_data::Dict, args...)
  path = nearestNeighbour(tsp_data, 1)
  goal = nodeWeightSum(path, tsp_data[:weights])
  for i in 2:tsp_data[:dimension]
    tmp_path = nearestNeighbour(tsp_data, i)
    tmp_goal = nodeWeightSum(tmp_path, tsp_data[:weights])
    if (tmp_goal < goal)
      goal = tmp_goal
      path = tmp_path
    end
  end
  return path
end

"""
    twoopt(tsp_data) -> Array{Integer}

Calculate best path of n nodes and their weights using 2-OPT algorithm.

Initial path is chosen at random using krandom().

## Params:
- `tsp_data::Dict`: `TSP` dataset.

## returns:
- `Array{Integer}` Best path computed.

"""
function twoopt(tsp_data::Dict, args...)
  steps = false
  if (length(args) == 1) steps = args[1] end
  path = krandom(tsp_data)
  function swap(x, y)
    swapped_path = copy(path)
    swapped_path[x:y] = swapped_path[y:-1:x]
    return swapped_path
  end
  best_distance = nodeWeightSum(path, tsp_data[:weights])
  for i in 1:length(path) - 1
    if (steps) println("STEP $i") end 
    for j in i+1:length(path)
      current_neigh = swap(i, j)
      @assert isperm(current_neigh)
      current_distance = nodeWeightSum(current_neigh, tsp_data[:weights])
      if (current_distance < best_distance) 
        best_distance = current_distance
        path = current_neigh
      end
    end
  end
  return path
end


saveplot = true
"""
    TSPtest(tsp_data, test_func, tests_num)

Runs `test_num` tests on given tsp_data dictionary.

Requires `test_func` function to compute path for current dataset.

## Params:
- `tsp_data::Dict`: `TSP` data.
- `test_func::{Function}`: function used to calculate a path for current TSP nodes.
- `tests_num::{Int}`: number of performed tests.

"""
function TSPtest(tsp_data::Dict, test_func::Function, objective::Function, tests_num::Int, args...)
  best_path=[]
  best_distance=typemax(Float64)
  for i in 1:tests_num
    println("\n\n======================TEST $i=====================")
    computed_path = test_func(tsp_data, args...)
    # Test info:
    println("Dataset name: ", tsp_data[:name])
    println("Nodes: ", tsp_data[:dimension])
    println("Path: ", computed_path)
    curr_distance = objective(computed_path, tsp_data[:weights])
    println("Distance: ", curr_distance)
    diff = curr_distance - best_distance
    println("Diff: ", (diff >= 0 ? "+$diff" : "$diff"))
    if (curr_distance < best_distance) 
      best_distance = curr_distance
      best_path = computed_path
    end
    println("==================END OF TEST $i==================")
  end

  println("\n\n=======================BEST=======================")
  println("Path: ", best_path)
  println("Distance: ", best_distance)
  println("Plot:")
  coords = getPathCoordsVector(best_path, tsp_data[:nodes])
  plt = UnicodePlots.lineplot(coords[1], coords[2]; title="Current path", height=20, width=40)
  UnicodePlots.scatterplot!(plt, coords[1], coords[2]; marker=repeat(["X"], length(best_path)))
  println(plt)
  println("===================END OF TESTS===================\n")

  if (!saveplot) return end
  now = Dates.now()
  println("Saving plot to: ./plots/$now.png\n")
  plt = plot(coords[1], coords[2]; title="Current path", markershape=:circle, margin=10Plots.mm)
  isdir("./plots") || mkdir("./plots")
  savefig(plt, "./plots/$now.png")
end

"""
Main program function
"""
function main(args::Array{String})
  if (length(ARGS) >= 1) tsp = readTSP(ARGS[1])
  else tsp = openTSPFile() end

  if (length(ARGS) >= 2)
    global saveplot = ARGS[2] == "no" ? false : true
  end

  dict_tsp = structToDict(tsp)
  TSPtest(dict_tsp, twoopt, nodeWeightSum, 1, true)
end

if abspath(PROGRAM_FILE) == @__FILE__
  main(ARGS)
end 